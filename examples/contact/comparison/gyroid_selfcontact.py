"""
Gyroid self-contact under compression: penalty vs IPC comparison
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example compares the two self-contact approaches available in fedoo
on a 3D gyroid unit cell under uniaxial compression.

  - **Penalty method** (``fd.constraint.SelfContact``): node-to-surface
    formulation with a user-tuned penalty parameter.
  - **IPC method** (``fd.constraint.IPCSelfContact``): barrier-potential
    formulation from the ipctk library guaranteeing intersection-free
    configurations.

The gyroid mesh (30k nodes, 114k tet4 elements) is loaded from a periodic
VTK file generated by microgen.  Simple compression BCs are applied
(no periodic BC) so that the gyroid walls buckle and self-contact occurs.

**Key finding:** The penalty self-contact method struggles on this mesh
(30k surface nodes, all-to-all contact search in pure Python) while IPC
(using ipctk's C++ hash-grid broad phase) scales well.

.. note::
   The IPC method requires the ``ipctk`` package:
   ``pip install ipctk``  or  ``pip install fedoo[ipc]``.
"""

import fedoo as fd
import numpy as np
import os
import sys
from time import time

os.chdir(os.path.dirname(os.path.abspath(__file__)) or ".")

MESH_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "../../../util/meshes/gyroid_per.vtk")
COMPRESSION = 0.15  # 15% compressive strain (height = 1.0)
RUN_PENALTY = "--penalty" in sys.argv  # opt-in: very slow on this mesh


def build_gyroid():
    """Load gyroid mesh and define elastic material."""
    fd.ModelingSpace("3D")
    mesh = fd.Mesh.read(MESH_PATH)

    # Linear elastic material
    material = fd.constitutivelaw.ElasticIsotrop(1e5, 0.3)

    return mesh, material


# =========================================================================
# Approach 1 : Penalty self-contact (opt-in, slow on 30k surface nodes)
# =========================================================================

penalty_solve_time = None
history_penalty = {
    "time": [],
    "nr_iters": [],
    "reaction_z": [],
    "contact_force_norm": [],
}

if RUN_PENALTY:
    print("=" * 60)
    print("PENALTY SELF-CONTACT (Gyroid compression)")
    print("=" * 60)

    mesh, material = build_gyroid()

    nodes_top = mesh.find_nodes("Z", mesh.bounding_box.zmax)
    nodes_bottom = mesh.find_nodes("Z", mesh.bounding_box.zmin)

    surf = fd.mesh.extract_surface(mesh)
    penalty_contact = fd.constraint.SelfContact(
        surf, "linear", search_algorithm="bucket"
    )
    penalty_contact.contact_search_once = True
    penalty_contact.eps_n = 1e5
    # max_dist must be very small for gyroid (walls ~0.05-0.1 apart)
    penalty_contact.max_dist = 0.03

    wf = fd.weakform.StressEquilibrium(material, nlgeom="UL")
    solid_assembly = fd.Assembly.create(wf, mesh)
    assembly = fd.Assembly.sum(solid_assembly, penalty_contact)

    pb_penalty = fd.problem.NonLinear(assembly)

    if not os.path.isdir("results"):
        os.mkdir("results")
    res_penalty = pb_penalty.add_output(
        "results/gyroid_penalty", solid_assembly, ["Disp", "Stress"]
    )

    pb_penalty.bc.add("Dirichlet", nodes_bottom, "Disp", 0)
    pb_penalty.bc.add("Dirichlet", nodes_top, "Disp", [0, 0, -COMPRESSION])
    pb_penalty.set_nr_criterion("Displacement", tol=5e-3, max_subiter=10)

    _penalty_prev_niter = [0]

    def track_penalty(pb):
        history_penalty["time"].append(pb.time)
        nr_this = pb.n_iter - _penalty_prev_niter[0]
        _penalty_prev_niter[0] = pb.n_iter
        history_penalty["nr_iters"].append(nr_this)
        F = pb.get_ext_forces("Disp")
        history_penalty["reaction_z"].append(np.sum(F[2, nodes_top]))
        gv = penalty_contact.current.global_vector
        history_penalty["contact_force_norm"].append(
            np.linalg.norm(gv) if not np.isscalar(gv) else 0.0
        )

    t0 = time()
    try:
        pb_penalty.nlsolve(
            dt=0.01, tmax=1, update_dt=True, print_info=2, interval_output=0.1,
            callback=track_penalty, exec_callback_at_each_iter=True,
        )
        penalty_solve_time = time() - t0
        print(f"Penalty solve time: {penalty_solve_time:.2f} s")
    except Exception as e:
        penalty_solve_time = time() - t0
        print(f"Penalty FAILED after {penalty_solve_time:.2f} s: {e}")
else:
    print("=" * 60)
    print("PENALTY SELF-CONTACT: SKIPPED")
    print("  (30k surface nodes -- pure-Python contact search is very slow)")
    print("  Run with --penalty flag to include penalty method.")
    print("=" * 60)


# =========================================================================
# Approach 2 : IPC self-contact
# =========================================================================

print("\n" + "=" * 60)
print("IPC SELF-CONTACT (Gyroid compression)")
print("=" * 60)

mesh2, material2 = build_gyroid()

nodes_top2 = mesh2.find_nodes("Z", mesh2.bounding_box.zmax)
nodes_bottom2 = mesh2.find_nodes("Z", mesh2.bounding_box.zmin)

ipc_contact = fd.constraint.IPCSelfContact(
    mesh2,
    dhat=5e-3,
    dhat_is_relative=True,
    friction_coefficient=0.0,
    use_ccd=True,
)

wf2 = fd.weakform.StressEquilibrium(material2, nlgeom="UL")
solid_assembly2 = fd.Assembly.create(wf2, mesh2)
assembly2 = fd.Assembly.sum(solid_assembly2, ipc_contact)

pb_ipc = fd.problem.NonLinear(assembly2)

if not os.path.isdir("results"):
    os.mkdir("results")
res_ipc = pb_ipc.add_output(
    "results/gyroid_ipc", solid_assembly2, ["Disp", "Stress"]
)

pb_ipc.bc.add("Dirichlet", nodes_bottom2, "Disp", 0)
pb_ipc.bc.add("Dirichlet", nodes_top2, "Disp", [0, 0, -COMPRESSION])
pb_ipc.set_nr_criterion("Displacement", tol=5e-3, max_subiter=10)

# --- Tracking callback ---
history_ipc = {
    "time": [],
    "nr_iters": [],
    "reaction_z": [],
    "contact_force_norm": [],
    "n_collisions": [],
    "kappa": [],
    "min_distance": [],
}
_ipc_prev_niter = [0]


def track_ipc(pb):
    history_ipc["time"].append(pb.time)
    nr_this = pb.n_iter - _ipc_prev_niter[0]
    _ipc_prev_niter[0] = pb.n_iter
    history_ipc["nr_iters"].append(nr_this)
    # Reaction force at top (Z component)
    F = pb.get_ext_forces("Disp")
    history_ipc["reaction_z"].append(np.sum(F[2, nodes_top2]))
    # Contact force norm
    history_ipc["contact_force_norm"].append(
        np.linalg.norm(ipc_contact.global_vector)
    )
    # IPC-specific metrics
    history_ipc["n_collisions"].append(len(ipc_contact._collisions))
    history_ipc["kappa"].append(ipc_contact._kappa)
    # Minimum distance (gap)
    verts = ipc_contact._get_current_vertices(pb)
    if len(ipc_contact._collisions) > 0:
        min_d = ipc_contact._collisions.compute_minimum_distance(
            ipc_contact._collision_mesh, verts
        )
    else:
        min_d = float("inf")
    history_ipc["min_distance"].append(min_d)


t0 = time()
pb_ipc.nlsolve(
    dt=0.05, tmax=1, update_dt=True, print_info=1, interval_output=0.1,
    callback=track_ipc, exec_callback_at_each_iter=True,
)
ipc_solve_time = time() - t0
print(f"IPC solve time: {ipc_solve_time:.2f} s")


# =========================================================================
# Comparison summary
# =========================================================================

print("\n")
print("=" * 62)
print("  PERFORMANCE COMPARISON: Penalty vs IPC Self-Contact")
print("  (Gyroid unit cell, {:.0f}% compression)".format(COMPRESSION * 100))
print("=" * 62)

total_nr_ipc = sum(history_ipc["nr_iters"])

if history_penalty["time"]:
    total_nr_penalty = sum(history_penalty["nr_iters"])
    pen_time_str = f"{penalty_solve_time:.2f} s" if penalty_solve_time else "FAILED"
    pen_inc_str = str(len(history_penalty["time"]))
    pen_nr_str = str(total_nr_penalty)
    pen_avg_str = f"{total_nr_penalty / max(len(history_penalty['time']), 1):.1f}"
    pen_fz_str = f"{history_penalty['reaction_z'][-1]:.2f}" if history_penalty["reaction_z"] else "N/A"
    pen_fc_str = f"{max(history_penalty['contact_force_norm']):.2f}" if history_penalty["contact_force_norm"] else "N/A"
    pen_fc_final = f"{history_penalty['contact_force_norm'][-1]:.2f}" if history_penalty["contact_force_norm"] else "N/A"
else:
    pen_time_str = "SKIPPED"
    pen_inc_str = pen_nr_str = pen_avg_str = pen_fz_str = pen_fc_str = pen_fc_final = "---"

rows = [
    ("Total solve time", pen_time_str, f"{ipc_solve_time:.2f} s"),
    ("Total increments", pen_inc_str, str(len(history_ipc["time"]))),
    ("Total NR iterations", pen_nr_str, str(total_nr_ipc)),
    ("Avg NR iter / increment", pen_avg_str,
     f"{total_nr_ipc / max(len(history_ipc['time']), 1):.1f}"),
    ("Final reaction Fz", pen_fz_str,
     f"{history_ipc['reaction_z'][-1]:.2f}" if history_ipc["reaction_z"] else "N/A"),
    ("Max contact force norm", pen_fc_str,
     f"{max(history_ipc['contact_force_norm']):.2f}" if history_ipc["contact_force_norm"] else "N/A"),
    ("Final contact force norm", pen_fc_final,
     f"{history_ipc['contact_force_norm'][-1]:.2f}" if history_ipc["contact_force_norm"] else "N/A"),
    ("IPC min gap distance", "N/A",
     f"{min(d for d in history_ipc['min_distance'] if np.isfinite(d)):.2e}" if any(np.isfinite(d) for d in history_ipc["min_distance"]) else "inf"),
    ("IPC final barrier kappa", "N/A",
     f"{history_ipc['kappa'][-1]:.2e}" if history_ipc["kappa"] else "N/A"),
    ("IPC max active collisions", "N/A",
     str(max(history_ipc["n_collisions"])) if history_ipc["n_collisions"] else "N/A"),
]

w_label = 28
w_val = 16
print(f"{'Metric':<{w_label}} {'Penalty':>{w_val}} {'IPC':>{w_val}}")
print("-" * (w_label + 2 * w_val + 2))
for label, v_pen, v_ipc in rows:
    print(f"{label:<{w_label}} {v_pen:>{w_val}} {v_ipc:>{w_val}}")
print()


# =========================================================================
# Per-increment detail tables
# =========================================================================

if history_penalty["time"]:
    print("-" * 62)
    print("  Per-increment detail: PENALTY")
    print("-" * 62)
    print(f"{'Inc':>4} {'Time':>8} {'NR iter':>8} {'Reaction Fz':>14} {'|F_contact|':>14}")
    for i in range(len(history_penalty["time"])):
        print(
            f"{i+1:4d} {history_penalty['time'][i]:8.4f} "
            f"{history_penalty['nr_iters'][i]:8d} "
            f"{history_penalty['reaction_z'][i]:14.2f} "
            f"{history_penalty['contact_force_norm'][i]:14.2f}"
        )
    print()

print("-" * 62)
print("  Per-increment detail: IPC")
print("-" * 62)
print(
    f"{'Inc':>4} {'Time':>8} {'NR iter':>8} {'Reaction Fz':>14} "
    f"{'|F_contact|':>14} {'Collisions':>11} {'Min gap':>12} {'Kappa':>12}"
)
for i in range(len(history_ipc["time"])):
    min_d = history_ipc["min_distance"][i]
    min_d_str = f"{min_d:.2e}" if np.isfinite(min_d) else "inf"
    print(
        f"{i+1:4d} {history_ipc['time'][i]:8.4f} "
        f"{history_ipc['nr_iters'][i]:8d} "
        f"{history_ipc['reaction_z'][i]:14.2f} "
        f"{history_ipc['contact_force_norm'][i]:14.2f} "
        f"{history_ipc['n_collisions'][i]:11d} "
        f"{min_d_str:>12} "
        f"{history_ipc['kappa'][i]:12.2e}"
    )

print()

# =========================================================================
# Optional plots (requires matplotlib)
# =========================================================================

try:
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    fig.suptitle(
        f"Gyroid Self-Contact -- IPC ({COMPRESSION*100:.0f}% compression)",
        fontsize=14,
    )

    # Reaction force vs time
    ax = axes[0, 0]
    if history_penalty["time"]:
        ax.plot(history_penalty["time"], history_penalty["reaction_z"],
                "o-", label="Penalty", markersize=3)
    ax.plot(history_ipc["time"], history_ipc["reaction_z"],
            "s-", label="IPC", markersize=3)
    ax.set_xlabel("Time")
    ax.set_ylabel("Reaction Fz")
    ax.set_title("Reaction Force (Z) at Top")
    ax.legend()
    ax.grid(True, alpha=0.3)

    # Contact force norm vs time
    ax = axes[0, 1]
    if history_penalty["time"]:
        ax.plot(history_penalty["time"], history_penalty["contact_force_norm"],
                "o-", label="Penalty", markersize=3)
    ax.plot(history_ipc["time"], history_ipc["contact_force_norm"],
            "s-", label="IPC", markersize=3)
    ax.set_xlabel("Time")
    ax.set_ylabel("||F_contact||")
    ax.set_title("Contact Force Norm")
    ax.legend()
    ax.grid(True, alpha=0.3)

    # NR iterations per increment
    ax = axes[1, 0]
    if history_penalty["time"]:
        ax.bar(np.arange(len(history_penalty["nr_iters"])) - 0.2,
               history_penalty["nr_iters"], width=0.4, label="Penalty")
    if history_ipc["time"]:
        offset = 0.2 if history_penalty["time"] else 0.0
        ax.bar(np.arange(len(history_ipc["nr_iters"])) + offset,
               history_ipc["nr_iters"], width=0.4, label="IPC")
    ax.set_xlabel("Increment")
    ax.set_ylabel("NR Iterations")
    ax.set_title("Newton-Raphson Iterations per Increment")
    ax.legend()
    ax.grid(True, alpha=0.3)

    # IPC-specific: min gap distance
    ax = axes[1, 1]
    finite_gaps = [(t, d) for t, d in zip(history_ipc["time"], history_ipc["min_distance"])
                   if np.isfinite(d)]
    if finite_gaps:
        t_gap, d_gap = zip(*finite_gaps)
        ax.plot(t_gap, d_gap, "s-", color="tab:green", markersize=3, label="Min gap")
    ax.set_xlabel("Time")
    ax.set_ylabel("Min Gap Distance")
    ax.set_title("IPC Minimum Gap Distance")
    ax.axhline(y=0, color="red", linestyle="--", alpha=0.5, label="Zero (penetration)")
    ax.legend()
    ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig("results/gyroid_penalty_vs_ipc_comparison.png", dpi=150)
    print("Comparison plot saved to results/gyroid_penalty_vs_ipc_comparison.png")
    plt.show()

except ImportError:
    print("matplotlib not available -- skipping plots.")


# =========================================================================
# Post-processing (requires pyvista)
# =========================================================================
# Uncomment the lines below to visualise interactively.

# if RUN_PENALTY:
#     res_penalty.plot("Stress", "vm", "Node", show=True, scale=1)
# res_ipc.plot("Stress", "vm", "Node", show=True, scale=1)

# --- Video output (uncomment to export MP4) ---
# res_ipc.write_movie("results/gyroid_ipc", "Stress", "vm", "Node",
#                     framerate=10, quality=8)
# print("Movie saved to results/gyroid_ipc.mp4")
